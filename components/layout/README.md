### Property value

![value](https://i.imgur.com/qkTmOFJ.png)

### Visual model

```
|-------------------------------------------------|
|                                                 |
|                  margin-top                     |
|                                                 |
|    |---------------------------------------|    |
|    |                                       |    |
|    |             border-top                |    |
|    |                                       |    |
|    |    |--------------------------|--|    |    |
|    |    |                          |  |    |    |
|    |    |       padding-top        |##|    |    |
|    |    |                          |##|    |    |
|    |    |    |----------------|    |##|    |    |
|    |    |    |                |    |  |    |    |
| ML | BL | PL |  content box   | PR |SW| BR | MR |
|    |    |    |                |    |  |    |    |
|    |    |    |----------------|    |  |    |    |
|    |    |                          |  |    |    |
|    |    |      padding-bottom      |  |    |    |
|    |    |                          |  |    |    |
|    |    |--------------------------|--|    |    |
|    |    |     scrollbar height ####|SC|    |    |
|    |    |-----------------------------|    |    |
|    |                                       |    |
|    |           border-bottom               |    |
|    |                                       |    |
|    |---------------------------------------|    |
|                                                 |
|                margin-bottom                    |
|                                                 |
|-------------------------------------------------|

BL = border-left
BR = border-right
ML = margin-left
MR = margin-right
PL = padding-left
PR = padding-right
SC = scroll corner
SW = scrollbar width
```

- Vertical scrollbar (if existing) will be on left in right-to-left direction horizontal writting mode, while horizontal scrollbar (if existing) is always at the bottom <- [illustration above and reference](https://chromium.googlesource.com/chromium/src/+/refs/heads/main/third_party/blink/renderer/core/layout/README.md#box-model).
- `box-sizing` changes which area `width`, `max/min-width`, `height`, `max/min-height` points to
  - `content-box` -> content area
  - `border-box` -> border area
- `display` establishes outer display (block/inline box) which defines how element's participation in [Normal Flow](https://www.w3.org/TR/CSS22/visuren.html#normal-flow) and inner display which defines formating context for its content.
- HTML elements generate zero or more boxes according to box model. How a box laid out according to box's type and position scheme (normal flow, float, and absolute positioning)

### Formatting model

![block](https://i.imgur.com/WrSJfCR.png)

#### Block

Block-level elements are formatted visually as block (occupy the entire horizontal space of its parent), and block-level elements generate block-level boxes which participle in a block formatting context. In block formatting context, boxes are laid out one after others vertically, beginning at the top of [a containing block](https://www.w3.org/TR/CSS22/visudet.html#containing-block-details).

Everything when rendering has to be in a box, in the example above there is no HTML element attached to, therefore, anonymous box is created. The properties of anonymous boxes are inherited from enclosing non-anonymous box (in example below is div), non-inherited properties have their initial value.

```html
<div>
  I am wrapped in an anonymous box
  <p>I am in the paragraph</p>
  I am wrapped in an anonymous box.
</div>
```

![anonymous box](https://i.imgur.com/qOrZtgL.png)

Anonymous box is also ignored when resolving percentage values, for example child of anonymous block box, which inside div, need to know its containing block height to resolve a percentage height, then it will use the height of div instead.

ðŸ™‹ Both block-level and inline-level elements can establish block formatting context.

#### Inline

Inline-level elements do not form new block of content, and inline-level elements generate inline-level boxes which participate in an inline formating context. In inline formating context, boxes are laid out horizontally one after other, beginning at the top of a containning block.

In example below, p generates a block box, two anonymous boxes (for "Hello" and "my old friend") and another inline box is generated by `em`.

```html
<p>Hello <em>darkness</em>, my old friend</p>
```

ðŸ™‹ Only block-level elements can establish inline formatting context (inline-block elements which contain only inline-level elements can establish a BFC and IFC simultaneously <- to simplify our implementation we create a anonymous block for their inline-level elements children).

### Stacking context

Each box belongs to one stacking context (it is formed in [following conditions](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context#the_stacking_context)) and describes [the order](https://www.w3.org/TR/CSS22/zindex.html#painting-order) in which rendering tree is painted.

[![hirerachy](https://i.imgur.com/TkAOJZi.png)](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context#the_example)

In the example above, every positioned elements create its own stacking context and we have a hierarchy of stacking context below.
Each stacking context is self-contained for example when rendering root we only care div #1, #2, #3 (belong to the same stacking context root) and then later when processing div #3, it is between div #4, #5, #6 (belongs to the same context div #3)

```
root
â”œâ”€â”€ div #1
â”œâ”€â”€ div #2
â”œâ”€â”€ div #3
|   â”œâ”€â”€ div #4
|   â”œâ”€â”€ div #5
|   â””â”€â”€ div #6
```

### Collapsing margins

[Collapsed margin](https://www.w3.org/TR/CSS22/box.html#collapsing-margins) is adjoining margins (apply event for zero margin) of two or more boxes (might or might not be siblings) are combined to form a single margin. Horizontal margins never collapse.

```html
<div id="1" style="margin: 10px 0">
  <p id="2" style="margin: 5px 0">ping</p>
</div>
<div id="3" style="margin: 15px 0 5px 0"></div>
<div id="4">
  <div id="5" style="margin: 20px 0">pong</div>
</div>
```

In the example above, margin bottoms of div#1 and p#2 are collapsed into 10px (A). Collapse through(top and bottom of a box are adjoining) happens for div#3, we have only one margin of 15px, then is collapsed with A to have 15px (B), later B is collapsed with margin top div#4 into 20px (div#1 and div#5 are not siblings).

### CSS Selector

#### Performance Tweak

There are [4 ways](https://calendar.perfplanet.com/2011/css-selector-performance-has-changed-for-the-better/) which are used by Webkit to improve performance ([77740](http://trac.webkit.org/changeset/77740/webkit), [77777](http://trac.webkit.org/changeset/77777/webkit))

- Style sharing: if browser has already calculated the p1's style, it can be reused for p2.
  ```html
  <div>
    <p>foo</p>
    <p>bar</p>
  </div>
  ```
- Rule hashes: since browser matches styles from right to left, we can group stylesheet by right most selector.
  ```scs1
  a {}
  div p {}
  div p.legal {}
  #sidebar a {}
  #sidebar p {}
  ```
  | a               |        p        |          p.legal |
  | --------------- | :-------------: | ---------------: |
  | `a {}`          |   `div p {}`    | `div p.legal {}` |
  | `#sidebar a {}` | `#sidebar p {}` |                  |
- Ancestor filters: use Bloom filter to test selector is probably in the set or not ([how Bloom filter works](https://www.jasondavies.com/bloomfilter/)).
- Fast path: re-implements matching logic for general matching logic using a non-recursive, fully inlined loop.

### Debugging

- We can view [layers information](https://developer.chrome.com/docs/devtools/evaluate-performance/reference/#layers) and how elements are painted in a canvas via [paint profiler](https://developer.chrome.com/docs/devtools/evaluate-performance/reference/#paint-profiler)

### Design

- Loop through stylesheet's css rules and build stylist's rules

```rs
// holds all selectors for a given document
struct Stylist {
  stylesheets: Vec<Stylesheet>,
  rules: Vec<Rule>,
  rules_source_order: u32,
}

struct Rule {
  selector: Selector<Selectors>,
  hashes: AncestorHashes,
  source_order: u32,
  style_rule: StyleRule,
}
```

- Traverse dom tree, each element find matched selectors and combine them with inline style -> transform them into list of `ApplicableDeclarationBlock` -> cascade to get computed values.

```rs
struct ApplicableDeclarationBlock {
  source: StyleSource,
  specificity: u32,
}

enum StyleSource {
  StyleRule(StyleRule),
  DeclarationBlock(PropertyDeclarationBlock),
}
```

- Traverse style tree to construct flow tree

ðŸ™‹ Current, we don't take white space (space, tab, newline ...) characters into consideration (which we should support)

```html
<span>
  <span>tata</span>
  <span>hello world</span>
</span>
---- vs
<span><span>tata</span><span>hello world</span></span>
---- vs
<span><span>tata </span><span>hello world</span></span>
```

### [Fragmentation](https://www.w3.org/TR/css-break-4/#fragmentation-model)

#### Visual fragment

![fragment](https://i.imgur.com/OdFpQyU.png)

#### Traverse direction

![traversal](https://i.imgur.com/BDBvFZm.png)

#### Implementation

```rs
pub struct IntrinsicSize {
	pub preferred_width: Pixel,
  pub preferred_minimum_width: Pixel,
  pub preferred_height: Pixel,
}
pub struct LayoutInfo {
  pub width: Pixel,
  pub height: Pixel,
  pub margin: Sides,
  pub padding: Sides,
  pub intrinsic_size: IntrinsicSize,
}

pub struct BlockLevelBox {
  lines: Vec<Line>, // only when establishing InlineFormattingContext, https://www.w3.org/TR/css3-linebox/#line-boxes
  fragment: BoxFragment,
}

pub struct InlineLevelBox {
  // if there is only one fragment -> it can have both sides.
  // else
  //  - the first one doesn't account right side for layout.
  //  - the following ones don't account left side for layout.
  fragments: Vec<BoxFragment>,
  max_width: Pixel, // use for inline-level elements with IFC to create next fragments (not first one), including width + sides
}

pub struct TextRun {
  fragments: Vec<TextFragment>,
}

pub struct AnonymousBox {
  lines: Vec<Line>, // anonymous box can establish a inline formatting context
  fragment: AnonymousFragment,
}

pub struct Line {
  fragments: Vec<Rc<Fragment>>,
  bounds: Rect<Pixel, CSSPixel>,
}

// content rect position is based on its parent
pub enum Fragment {
  BoxFragment,
  TextFragment,
  AnonymousFragment,
}
```

**Prepare**: post traversal box tree, to compute

- for block-level boxes, inline-level boxes (establish BFC)
  - update layout info if it has a fixed width/height and fixed margin/padding.
- intrinsic width for each box (B).
  - text run:
    - prefered mimimum width (PMW): split content by white space characters and PMW = max(each words).
    - prefered width (PW): using TextUI to render and calculate its content bounds.
  - inline formatting context (IFC):
    - PMW = max(all of B's children (PMW + fixed sides)) (1).
    - PW = sum all of B's children (PW + fixed sides) (1).
  - block formatting context (BFC):
    - PMW = max(all of B's children (PMW + fixed sides)) (1).
    - PW = max(all of B's children (PW + fixed sides)) (1).

(1) if child's width is fixed, using it instead of PMW or PW.

**Visit**: for each box B, if it is (after each visit, for block and inline-block elements, their width are known)

- block-level box (BL)
  - BL's parent (P), P is either block or inline-block -> only one box fragment (PF).
  - create a box fragment (F).
  - update layout info (width + horizontal sides) (https://www.w3.org/TR/CSS22/visudet.html#blockwidth).
  - F's width and horizontal sides = layout info.
  - F's bounded width = F's width.
- inline-level box (IL)
  - traverse IL's ancestors until reaching an ancestor with inline formatting context (A) (either block or anonymous box).
  - if A's lines empty
    - create a newline (AL) in A's lines.
  - else
    - get the latest A's lines (AL).
  - get IL's parent (P), P's latest fragment (PF). if P != A -> P has to be inline-level block with IFC.
  - IL's max_width = P's width.
  - if P is block or anonymous (P is A), PF's leftover width (PFW)
    - PFW = P's width - P's latest line width.
  - else
    - PFW = P's fragment leftover width.
  - create a box fragment (F).
  - if IL's formatting context:
    - block formatting context
      - F's width (FW) and sides (horizontal) (https://www.w3.org/TR/CSS22/visudet.html#inlineblock-width).
        - FW = min(max(IL's PMW, A's width - sides), IL's PW).
      - F's bounded width = F's width.
      - if FW + sides <= PFW || AL contains no fragment (1)
        - if IL is direct child of A -> append F into AL.
        - traverse [P..A), for each node N (which has to be inline-level elements)
          - N's latest fragment width += FW + sides.
      - else
        - relocate F to newline (simply reset F'x = 0).
        - create a newline (AL) in A's lines.
        - if IL is direct child of A -> append F into AL.
        - traverse [P..A), for each node N (which has to be inline-level elements) (2)
          - create a new box fragment (NF).
          - NF's bounded width = IL's max_width - right sides.
          - NF's width = previous width + right sides (starting at F's width).
          - if N is direct child of A -> append NF into AL.
    - inline formatting context
      - sides (https://www.w3.org/TR/CSS22/visudet.html#inline-width).
      - F's bounded width = PFW - F's sides.
- text run (TR)
  - traverse IL's ancestors until reaching an ancestor with inline formatting context (A) (either block or anonymous box).
  - if A's lines empty
    - create a newline (AL) in A's lines.
  - else
    - get the latest A's lines (AL).
  - get IL's parent (P), P's latest fragment (PF). if P != A -> P has to be inline-level block with IFC.
  - if P is block or anonymous (P is A), PF's leftover width (PFW)
    - PFW = P's width - P's latest line.
  - else
    - PFW = P's fragment leftover width.
  - create a text fragment (F).
  - if TR's PW <= PFW:
    - F's width = TR's PW.
    - (1).
  - else
    - split TR by words.
    - string S and append words until S's width larger than PFW -> F's width = S's width.
    - if TR is A's direct child -> append TR into A's lines.
    - for remaining TR's words
      - create a new text fragment (F1), F1's width = min(P's bounded width, remaining TR words width).
      - string S and append words until S's width larger than PFW -> F's width = S's width (1).
      - same as (2).
- anonymous box (AB)
  - create a anonymous fragment (F).
  - same as block-element box.

**Revisit**: for each box B, if it is

- context to keep track of current height.
- block-level box and anonymous box: if B's context type is
  - block formatting context: (1)
    - B's height = sum of all B's children height (don't support margin collapse).
  - inline formatting context:
    - B's height = sum of all B's lines height.
- inline-level box (IL): if IL's context type is
  - block formatting context:
    - same as (1)
  - inline formatting context:
    - IL's height = summ of all IL's fragments height.
    - only for the first fragment
      - if it is empty width -> remove it.

#### Notes

- text run should be in its own anonymous block box, https://codesandbox.io/s/reverent-sky-czvn1?file=/index.html
- https://codesandbox.io/s/lucid-kate-68itj?file=/index.html
